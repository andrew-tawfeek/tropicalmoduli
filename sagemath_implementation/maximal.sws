# num vertices = 2g - 2 + n
# num edges = 3g - 3 + n

#final graph satisfies deg(v) = 3 for all v
#BETTER: check deg(v) = 3 for some vertex then check is_regular


# Computing maximals...
# https://oeis.org/A005967/a005967.pdf


def initial(g,n):
    return Graph(2*g-2+n, multiedges = True, loops = True) #index at vertex 0

def loop(G,v): #adds loop to graph G at vertex v (an index)
    H = Graph(G, multiedges = True, loops = True) #stupid but safe
    H.edge(v,v)
    return H






#### TOWER BELOW
# missing ONLY those not having loops on leaves

def trivalent_trees(n): #connected trees on n-many vertices with deg at most 3
    L = list(graphs.CompleteGraph(n).spanning_trees())
    final = []
    for G in L:
        deg_list = [G.degree(v) for v in G.vertices()]
        parity_list = [x%2 for x in deg_list]
        if max(deg_list) <= 3 and len([i for i in parity_list if i==0])%2 == 0:
            final = final + [G]
    return final


def loopy_leaves(G): #loops the leaves
    H = Graph(G, multiedges = True, loops = True) #incase
    for v in H.vertices():
        if H.degree(v) == 1:
            H.add_edge(v,v)
    return H


def dupe_scheme(G): #turns all even deg vertices to multiedges
    H = Graph(G, multiedges = True, loops = True) #incase
    even_verts = [v for v in G.vertices() if G.degree(v) == 2]
    for v in even_verts:
        even_verts.remove(v)
        for w in even_verts:
            H.add_edge(v,w)
    return H

def loopy_dupe(G): #just does both the things above, everything output will have deg 3
    H = Graph(G, multiedges = True, loops = True) #incase
    even_verts = [v for v in G.vertices() if G.degree(v) == 2]
    leaves = [v for v in G.vertices() if G.degree(v) == 1]
    for v in even_verts:
        even_verts.remove(v)
        for w in even_verts:
            H.add_edge(v,w)
            even_verts.remove(w)
    for v in leaves:
        H.add_edge(v,v)
    return H


def looped_multi_trivalent_graphs(n):
    L = trivalent_trees(n)
    return [loopy_dupe(G) for G in L]
